<!-- Heterogeneous FPGA Architecture with Carry Chain for VPR8

  - The chip layout is organized with a 128x128 array of Configurable Logic Blocks (CLBs)
    surrounded by a ring of I/Os.
  - CLB / Memory block ratio is 30. The BRAMs are interspaced with CLB columns.
  - Columns of QL_DSP are interspaced with CLB columns, with one QL_DSP column per BRAM column.
  - Delay numbers are extracted from a 12 nm technology
    Process corner: TT 0.8V
  
  Author: Xifan Tang, Aurelien Alacchi, Ganesh Gore and Samy Charas
-->
<architecture>
  <!--
       ODIN II specific config begins
       Describes the types of user-specified netlist blocks (in blif, this corresponds to
       ".model [type_of_block]") that this architecture supports.

       Note: Basic LUTs, I/Os, and flip-flops are not included here as there are
       already special structures in blif (.names, .input, .output, and .latch)
       that describe them.
  -->
  <models>
   <model name="adder_lut4">
      <input_ports>
        <port name="in" combinational_sink_ports="lut4_out cout"/>
        <port name="cin" combinational_sink_ports="lut4_out cout"/>
      </input_ports>
      <output_ports>
        <port name="lut4_out"/>
        <port name="cout"/>
      </output_ports>
    </model>
    <!-- A virtual model for I/O to be used in the physical mode of io block -->
    <model name="io">
      <input_ports>
        <port name="outpad"/>
      </input_ports>
      <output_ports>
        <port name="inpad"/>
      </output_ports>
    </model>
    <!-- Flipflop models definition starts -->
    
    <model name="dff">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="C" is_clock="1"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffn">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="C" is_clock="1"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffr">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="C" is_clock="1"/>
        <port name="R" clock="C"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffnr">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="C" is_clock="1"/>
        <port name="R" clock="C"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffs">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="C" is_clock="1"/>
        <port name="S" clock="C"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffns">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="C" is_clock="1"/>
        <port name="S" clock="C"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffsr">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="C" is_clock="1"/>
        <port name="S" clock="C"/>
        <port name="R" clock="C"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <model name="dffnsr">
      <input_ports>
        <port name="D" clock="C"/>
        <port name="C" is_clock="1"/>
        <port name="S" clock="C"/>
        <port name="R" clock="C"/>
      </input_ports>
      <output_ports>
        <port name="Q" clock="C"/>
      </output_ports>
    </model>
    <!-- Flipflop models definition ends       -->
    <!-- Dual port ram model definition starts -->
    <model name="DP_RAM16K">
      <input_ports>
        <!-- write address lines -->
        <port name="waddr" clock="wclk"/>
        <!-- read address lines -->
        <port name="raddr" clock="rclk"/>
        <!-- data lines can be broken down into smaller bit widths minimum size 1 -->
        <port name="d_in" clock="wclk"/>
        <!-- write bit mask -->
        <port name="wenb" clock="wclk"/>
        <!-- write enable -->
        <port name="wen" clock="wclk"/>
        <!-- read enable -->
        <port name="ren" clock="rclk"/>
        <!-- memories are often clocked -->
        <port name="rclk" is_clock="1"/>
        <port name="wclk" is_clock="1"/>
      </input_ports>
      <output_ports>
        <!-- output can be broken down into smaller bit widths minimum size 1 -->
        <port name="d_out" clock="rclk"/>
      </output_ports>
    </model>
    <!-- Dual port ram model definition ends -->
    <!-- QL_DSP model definition starts     -->
    <model name="QL_DSP">
      <input_ports>
        <port name="A" combinational_sink_ports="O CO"/>
        <port name="B" combinational_sink_ports="O CO"/>
        <port name="C" combinational_sink_ports="O CO"/>
        <port name="D" combinational_sink_ports="O CO"/>
        <port name="CLK" is_clock="1"/>
      </input_ports>
      <output_ports>
        <port name="CO"/>
        <port name="O"/>
      </output_ports>
    </model>
    <!-- QL_DSP model definition ends -->
  </models>
  <tiles>
    <!-- Each I/O tile includes 8 GPIO -->
    <tile name="io" capacity="8" area="0">
      <equivalent_sites>
        <site pb_type="io"/>
      </equivalent_sites>
      <input name="outpad" num_pins="1"/>
      <output name="inpad" num_pins="1"/>
      <!-- Each input of the tile can be driven by 15% of routing tracks
           Each output of the tile can drive 10% of routing tracks
        -->
      <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
      <pinlocations pattern="custom">
        <loc side="left">io.outpad io.inpad</loc>
        <loc side="top">io.outpad io.inpad</loc>
        <loc side="right">io.outpad io.inpad</loc>
        <loc side="bottom">io.outpad io.inpad</loc>
      </pinlocations>
    </tile>
    <!-- Each CLB tile includes a Configurable Logic Block (CLB)
         Each input of the tile can be driven by 15% of routing tracks
         Each output of the tile can drive 10% of routing tracks
      -->
    <tile name="clb" area="53894">
      <equivalent_sites>
        <site pb_type="clb"/>
      </equivalent_sites>
      <input name="I0" num_pins="10" equivalent="full"/>
      <input name="I1" num_pins="10" equivalent="full"/>
      <input name="I2" num_pins="10" equivalent="full"/>
      <input name="I3" num_pins="10" equivalent="full"/>
      <input name="sc_in" num_pins="1"/>
      <input name="cin" num_pins="1"/>
      <input name="cin_trick" num_pins="1"/>
      <input name="set" num_pins="10"/>
      <input name="reset" num_pins="10"/>
      <input name="enable" num_pins="10"/>
      <input name="regin" num_pins="1"/>
      <output name="O" num_pins="16" equivalent="none"/>
      <output name="sc_out" num_pins="1"/>
      <output name="cout" num_pins="1"/>
      <output name="regout" num_pins="1"/>
      <clock name="clk" num_pins="1"/>
      <!-- Each input of the tile can be driven by 15% of routing tracks
           Each output of the tile can drive 10% of routing tracks
           There are four pins (cin, cout, sc_in, sc_out) has not connection
           to routing tracks. There are directed wired from/to adjacent CLBs
        -->
      <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10">
        <fc_override port_name="cin" fc_type="frac" fc_val="0"/>
        <fc_override port_name="cout" fc_type="frac" fc_val="0"/>
        <fc_override port_name="sc_in" fc_type="frac" fc_val="0"/>
        <fc_override port_name="sc_out" fc_type="frac" fc_val="0"/>
      </fc>
      <!-- To ensure best tileable routing architecture (minimize the number of unique SBs
           We keep all the pins that touch routing architecture on the right and bottom sides of the tile
           Top side pins are mainly for direct connections
        -->
      <pinlocations pattern="custom">
        <loc side="left"></loc>
        <loc side="top">clb.sc_in clb.cin clb.cin_trick clb.regin clb.clk clb.set[9:0] clb.reset[9:0] clb.enable[9:0]</loc>
        <loc side="right">clb.I0[9:0] clb.I1[9:0] clb.O[7:0]</loc>
        <loc side="bottom">clb.cout clb.sc_out clb.regout clb.I2[9:0] clb.I3[9:0] clb.O[15:8]</loc>
      </pinlocations>
    </tile>
    <tile name="memory" height="2" area="548000">
      <equivalent_sites>
        <site pb_type="memory"/>
      </equivalent_sites>
      <input name="waddr" num_pins="9"/>
      <input name="raddr" num_pins="9"/>
      <input name="d_in" num_pins="32"/>
      <input name="wenb" num_pins="32"/>
      <input name="wen" num_pins="1"/>
      <input name="ren" num_pins="1"/>
      <output name="d_out" num_pins="32"/>
      <clock name="rclk" num_pins="1"/>
      <clock name="wclk" num_pins="1"/>
      <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
      <pinlocations pattern="custom">
        <loc side="left"></loc>
        <loc side="top">memory.rclk memory.wclk</loc>
        <loc side="right">memory.waddr memory.d_in[15:0] memory.wen memory.d_out[15:0] memory.wenb[15:0]</loc>
        <loc side="bottom">memory.raddr memory.d_in[31:16] memory.ren memory.d_out[31:16] memory.wenb[31:16]</loc>
      </pinlocations>
    </tile>
    <tile name="QL_DSP" height="2" area="396000">
      <equivalent_sites>
        <site pb_type="QL_DSP" pin_mapping="direct"/>
      </equivalent_sites>
      <input name="a" num_pins="16"/>
      <input name="b" num_pins="16"/>
      <input name="c" num_pins="16"/>
      <input name="d" num_pins="16"/>
      <clock name="clk" num_pins="1"/>
      <output name="co" num_pins="1"/>
      <output name="o" num_pins="32"/>
      <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
      <pinlocations pattern="custom">
        <loc side="left">QL_DSP.a[15:0] QL_DSP.b[15:0] QL_DSP.c[15:0] QL_DSP.d[15:0]</loc>
        <loc side="top">QL_DSP.clk</loc>
        <loc side="right">QL_DSP.o[31:0] QL_DSP.co</loc>
        <loc side="bottom"></loc>
      </pinlocations>
    </tile>
  </tiles>
  <!-- ODIN II specific config ends -->
  <!-- Physical descriptions begin -->
  <device>
    <sizing R_minW_nmos="8926" R_minW_pmos="16067"/>
    <!-- The grid_logic_tile_area below will be used for all blocks that do not explicitly set their own (non-routing)
         area; set to 0 since we explicitly set the area of all blocks currently in this architecture file.
      -->
    <area grid_logic_tile_area="0"/>
    <chan_width_distr>
      <x distr="uniform" peak="1.000000"/>
      <y distr="uniform" peak="1.000000"/>
    </chan_width_distr>
    <!-- Use Wilton-style connecting pattern in switch block
         Each routing track has access to only three other routing tracks
         (one per each side of the switch block except the side where the routing track locates)
      -->
    <switch_block type="wilton" fs="3"/>
    <connection_block input_switch_name="ipin_cblock"/>
  </device>
  <switchlist>
    <switch type="mux" name="0" R="0" Cin="0" Cout="0" Tdel="200e-12" mux_trans_size="2.630740" buf_size="27.645901"/>
    <switch type="mux" name="ipin_cblock" R="0" Cout="0" Cin="0" Tdel="210e-12" mux_trans_size="1.222260" buf_size="auto"/>
  </switchlist>
  <segmentlist>
    <!-- GIVE a specific name for the segment! OpenFPGA appreciate that! -->
    <!-- Uni-directional routing architecture using only length-4 wires in routing channels -->
    <segment name="L4" freq="1.000000" length="4" type="unidir" Rmetal="10" Cmetal="1.6e-12">
      <mux name="0"/>
      <sb type="pattern">1 1 1 1 1</sb>
      <cb type="pattern">1 1 1 1</cb>
    </segment>
  </segmentlist>
  <directlist>
    <!-- Hard adder chain inside CLB is directly connected between adjacent CLBs -->
    <direct name="adder_carry" from_pin="clb.cout" to_pin="clb.cin" x_offset="0" y_offset="-1" z_offset="0"/>
    <!-- Scan chain inside CLB is directly connected between adjacent CLBs -->
    <direct name="scff_chain" from_pin="clb.sc_out" to_pin="clb.sc_in" x_offset="0" y_offset="-1" z_offset="0"/>
  </directlist>
  <complexblocklist>
    <!-- Define I/O pads begin -->
    <!-- Capacity is a unique property of I/Os, it is the maximum number of I/Os that can be placed at the same (X,Y) location on the FPGA -->
    <!-- Not sure of the area of an I/O (varies widely), and it's not relevant to the design of the FPGA core, so we're setting it to 0. -->
    <pb_type name="io">
      <input name="outpad" num_pins="1"/>
      <output name="inpad" num_pins="1"/>
      <!-- A mode denotes the physical implementation of an I/O
           This mode will be not packable but is mainly used for fabric verilog generation
        -->
      <mode name="physical" disable_packing="true">
        <pb_type name="iopad" blif_model=".subckt io" num_pb="1">
          <input name="outpad" num_pins="1"/>
          <output name="inpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="outpad" input="io.outpad" output="iopad.outpad">
            <delay_constant max="0" in_port="io.outpad" out_port="iopad.outpad"/>
          </direct>
          <direct name="inpad" input="iopad.inpad" output="io.inpad">
            <delay_constant max="0" in_port="iopad.inpad" out_port="io.inpad"/>
          </direct>
        </interconnect>
      </mode>
      <!-- IOs can operate as either inputs or outputs.
       Delays below come from Ian Kuon. They are small, so they should be interpreted as
       the delays to and from registers in the I/O (and generally I/Os are registered
       today and that is when you timing analyze them.
       -->
      <mode name="inpad">
        <pb_type name="inpad" blif_model=".input" num_pb="1">
          <output name="inpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="inpad" input="inpad.inpad" output="io.inpad">
            <delay_constant max="0" in_port="inpad.inpad" out_port="io.inpad"/>
          </direct>
        </interconnect>
      </mode>
      <mode name="outpad">
        <pb_type name="outpad" blif_model=".output" num_pb="1">
          <input name="outpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="outpad" input="io.outpad" output="outpad.outpad">
            <delay_constant max="0" in_port="io.outpad" out_port="outpad.outpad"/>
          </direct>
        </interconnect>
      </mode>
      <power method="ignore"/>
    </pb_type>
    <!-- Define I/O pads ends -->
    <!-- Define multi-mode Configurable Logic Block (CLB) begin -->
    <!-- Technical highlight:
         K6_frac_N10_I40_chain_shiftreg_depop50
         - K6_frac: Each Logic Element (LE) contains a fracturable 6 LUT,
                    which can operate as one 6-LUT or two 5-LUTs or four 4-LUTs
                    In addition to 6-LUT, each LE also includes two Flip-Flops
         - N10: every CLB consists of 10 LEs and a local routing architecture
         - I40: every CLB has 40 inputs
         - chain: a hard adder chain across all the LEs in a CLB
                  The inputs of adder are driven by 4-LUTs.
                  The sumout of adder can optional drive an LE output or a Flip-Flop
                  The carry-out of adder will drive the carry-in of the next adder in the chain
         - shiftreg: Flip-flops inside CLB can be configured as shift registers.
                     The organization is similar the hard adder chain except it is programmable
         - depop50: every local routing multiplexer accesses to 50% of the CLB inputs
      -->
    <pb_type name="clb">
      <input name="I0" num_pins="10" equivalent="full"/>
      <input name="I1" num_pins="10" equivalent="full"/>
      <input name="I2" num_pins="10" equivalent="full"/>
      <input name="I3" num_pins="10" equivalent="full"/>
      <input name="sc_in" num_pins="1"/>
      <input name="cin" num_pins="1"/>
      <input name="cin_trick" num_pins="1"/>
      <input name="set" num_pins="10"/>
      <input name="reset" num_pins="10"/>
      <input name="enable" num_pins="10"/>
      <input name="regin" num_pins="1"/>
      <output name="O" num_pins="16" equivalent="none"/>
      <output name="sc_out" num_pins="1"/>
      <output name="cout" num_pins="1"/>
      <output name="regout" num_pins="1"/>
      <clock name="clk" num_pins="1"/>

      <!-- Describe fracturable logic element -->
      <pb_type name="fle" num_pb="8">
        <input name="in" num_pins="4"/>
        <input name="reg_in" num_pins="1"/>
        <input name="sc_in" num_pins="1"/>
        <input name="cin" num_pins="1"/>
        <input name="reset" num_pins="1"/>
        <input name="preset" num_pins="1"/>
        <output name="out" num_pins="1"/>
        <output name="reg_out" num_pins="1"/>
        <output name="sc_out" num_pins="1"/>
        <output name="cout" num_pins="1"/>
        <clock name="clk" num_pins="1"/>


        <mode name="arithmetic">
          <pb_type name="soft_adder" num_pb="1">
            <input name="in" num_pins="4"/>
            <input name="cin" num_pins="1"/>
            <output name="sumout" num_pins="1"/>
            <output name="cout" num_pins="1"/>
            <pb_type name="adder_lut4" blif_model=".subckt adder_lut4" num_pb="1">
              <input name="cin" num_pins="1"/>
              <input name="in" num_pins="4"/>
              <output name="lut4_out" num_pins="1"/>
              <output name="cout" num_pins="1"/>
              <delay_constant max="2.49e-10" min="2e-10" in_port="adder_lut4.cin" out_port="adder_lut4.lut4_out"/>
              <delay_constant max="4.7e-11" min="3.9e-11" in_port="adder_lut4.cin" out_port="adder_lut4.cout"/>
              <delay_constant max="2.02e-10" min="8.8e-11" in_port="adder_lut4.in" out_port="adder_lut4.cout"/>
              <delay_matrix type="max" in_port="adder_lut4.in" out_port="adder_lut4.lut4_out">
                3.3e-10
                3e-10
                2.5e-10
                2.5e-10
              </delay_matrix>
              <delay_matrix type="min" in_port="adder_lut4.in" out_port="adder_lut4.lut4_out">
                2.4e-10
                2e-10
                2e-10
                2e-10
              </delay_matrix>
            </pb_type>
            <interconnect>
              <direct name="direct1" input="soft_adder.in" output="adder_lut4.in"/>
              <direct name="direct3" input="soft_adder.cin" output="adder_lut4.cin">
                <pack_pattern name="chain" in_port="soft_adder.cin" out_port="adder_lut4.cin"/>
              </direct>
              <direct name="direct4" input="adder_lut4.cout" output="soft_adder.cout">
                <pack_pattern name="chain" in_port="adder_lut4.cout" out_port="soft_adder.cout"/>
              </direct>
              <direct name="direct5" input="adder_lut4.lut4_out" output="soft_adder.sumout[0:0]">
              </direct>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct1" input="fle.in" output="soft_adder.in"/>
            <direct name="direct2" input="fle.cin" output="soft_adder.cin">
              <pack_pattern name="chain" in_port="fle.cin" out_port="soft_adder.cin"/>
            </direct>
            <direct name="direct3" input="soft_adder.sumout" output="fle.out[0:0]"/>
            <direct name="direct4" input="soft_adder.cout" output="fle.cout">
              <pack_pattern name="chain" in_port="soft_adder.cout" out_port="fle.cout"/>
            </direct>
          </interconnect>
        </mode>

        <!-- Define n1_lut4 mode ends -->
        <mode name="n1_lut4">
          <pb_type name="ble4" num_pb="1">
            <input name="in" num_pins="4"/>
            <input name="reset" num_pins="1"/>
            <input name="preset" num_pins="1"/>
            <output name="out" num_pins="1"/>
            <clock name="clk" num_pins="1"/>
            <pb_type name="lut4" blif_model=".names" num_pb="1" class="lut">
              <input name="in" num_pins="4" port_class="lut_in"/>
              <output name="out" num_pins="1" port_class="lut_out"/>
              <delay_matrix type="max" in_port="lut4.in" out_port="lut4.out">
                3.3e-10
                3e-10
                2.5e-10
                2.5e-10
              </delay_matrix>
              <delay_matrix type="min" in_port="lut4.in" out_port="lut4.out">
                2.4e-10
                2e-10
                2e-10
                2e-10
              </delay_matrix>
            </pb_type>
            <pb_type name="ff" num_pb="1">
              <input name="D" num_pins="1"/>
              <input name="R" num_pins="1"/>
              <input name="S" num_pins="1"/>
              <output name="Q" num_pins="1"/>
              <clock name="clk" num_pins="1"/>
              <mode name="LATCH">
                <pb_type name="LATCH" blif_model=".latch" num_pb="1" class="flipflop">
                  <input name="D" num_pins="1" port_class="D"/>
                  <output name="Q" num_pins="1" port_class="Q"/>
                  <clock name="clk" num_pins="1" port_class="clock"/>
                  <T_setup value="5.2e-11" port="LATCH.D" clock="clk"/>
                  <T_hold value="0.0" port="LATCH.D" clock="clk"/>
                  <T_clock_to_Q max="8.4e-11" port="LATCH.Q" clock="clk"/>
                </pb_type>
                <interconnect>
                  <direct input="LATCH.Q" name="LATCH-Q" output="ff.Q"/>
                  <direct input="ff.D" name="LATCH-D" output="LATCH.D">
                    <pack_pattern name="LUT+LATCH" in_port="ff.D" out_port="LATCH.D"/>
                  </direct>
                  <direct input="ff.clk" name="LATCH-clk" output="LATCH.clk"/>
                </interconnect>
              </mode>
              <mode name="DFF">
                <pb_type name="DFF" blif_model=".subckt dff" num_pb="1">
                  <input name="D" num_pins="1"/>
                  <output name="Q" num_pins="1"/>
                  <clock name="C" num_pins="1"/>
                  <T_setup value="5.2e-11" port="DFF.D" clock="C"/>
                  <T_hold value="0.0" port="DFF.D" clock="C"/>
                  <T_clock_to_Q max="8.4e-11" port="DFF.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct input="DFF.Q" name="FF-Q" output="ff.Q"/>
                  <direct input="ff.D" name="DFF-D" output="DFF.D">
                    <pack_pattern name="LUT+DFF" in_port="ff.D" out_port="DFF.D"/>
                  </direct>
                  <direct input="ff.clk" name="DFF-clk" output="DFF.C"/>
                </interconnect>
              </mode>
              <mode name="DFFN">
                <pb_type name="DFFN" blif_model=".subckt dffn" num_pb="1">
                  <input name="D" num_pins="1"/>
                  <output name="Q" num_pins="1"/>
                  <clock name="C" num_pins="1"/>
                  <T_setup value="5.2e-11" port="DFFN.D" clock="C"/>
                  <T_hold value="0.0" port="DFFN.D" clock="C"/>
                  <T_clock_to_Q max="8.4e-11" port="DFFN.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct input="DFFN.Q" name="FF-Q" output="ff.Q"/>
                  <direct input="ff.D" name="DFFN-D" output="DFFN.D">
                    <pack_pattern name="LUT+DFFN" in_port="ff.D" out_port="DFFN.D"/>
                  </direct>
                  <direct input="ff.clk" name="DFFN-clk" output="DFFN.C"/>
                </interconnect>
              </mode>
              <mode name="DFFR">
                <pb_type name="DFFR" blif_model=".subckt dffr" num_pb="1">
                  <input name="D" num_pins="1"/>
                  <input name="R" num_pins="1"/>
                  <output name="Q" num_pins="1"/>
                  <clock name="C" num_pins="1"/>
                  <T_setup value="5.2e-11" port="DFFR.D" clock="C"/>
                  <T_hold value="0.0" port="DFFR.D" clock="C"/>
                  <T_setup value="2e-11" port="DFFR.R" clock="C"/>
                  <T_hold value="7e-11" port="DFFR.R" clock="C"/>
                  <T_clock_to_Q max="8.4e-11" port="DFFR.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct input="DFFR.Q" name="FF-Q" output="ff.Q"/>
                  <direct input="ff.D" name="DFFR-D" output="DFFR.D">
                    <pack_pattern name="LUT+DFFR" in_port="ff.D" out_port="DFFR.D"/>
                  </direct>
                  <direct input="ff.clk" name="DFFR-clk" output="DFFR.C"/>
                  <direct input="ff.R" name="DFFR-reset" output="DFFR.R"/>
                </interconnect>
              </mode>
              <mode name="DFFNR">
                <pb_type name="DFFNR" blif_model=".subckt dffnr" num_pb="1">
                  <input name="D" num_pins="1"/>
                  <input name="R" num_pins="1"/>
                  <output name="Q" num_pins="1"/>
                  <clock name="C" num_pins="1"/>
                  <T_setup value="5.2e-11" port="DFFNR.D" clock="C"/>
                  <T_hold value="0.0" port="DFFNR.D" clock="C"/>
                  <T_setup value="2e-11" port="DFFNR.R" clock="C"/>
                  <T_hold value="7e-11" port="DFFNR.R" clock="C"/>
                  <T_clock_to_Q max="8.4e-11" port="DFFNR.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct input="DFFNR.Q" name="FF-Q" output="ff.Q"/>
                  <direct input="ff.D" name="DFFNR-D" output="DFFNR.D">
                    <pack_pattern name="LUT+DFFNR" in_port="ff.D" out_port="DFFNR.D"/>
                  </direct>
                  <direct input="ff.clk" name="DFFNR-clk" output="DFFNR.C"/>
                  <direct input="ff.R" name="DFFNR-reset" output="DFFNR.R"/>
                </interconnect>
              </mode>
              <mode name="DFFS">
                <pb_type name="DFFS" blif_model=".subckt dffs" num_pb="1">
                  <input name="D" num_pins="1"/>
                  <input name="S" num_pins="1"/>
                  <output name="Q" num_pins="1"/>
                  <clock name="C" num_pins="1"/>
                  <T_setup value="5.2e-11" port="DFFS.D" clock="C"/>
                  <T_hold value="0.0" port="DFFS.D" clock="C"/>
                  <T_setup value="2e-11" port="DFFS.S" clock="C"/>
                  <T_hold value="7e-11" port="DFFS.S" clock="C"/>
                  <T_clock_to_Q max="8.4e-11" port="DFFS.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct input="DFFS.Q" name="FF-Q" output="ff.Q"/>
                  <direct input="ff.D" name="DFFS-D" output="DFFS.D">
                    <pack_pattern name="LUT+DFFS" in_port="ff.D" out_port="DFFS.D"/>
                  </direct>
                  <direct input="ff.clk" name="DFFS-clk" output="DFFS.C"/>
                  <direct input="ff.S" name="DFFS-preset" output="DFFS.S"/>
                </interconnect>
              </mode>
              <mode name="DFFNS">
                <pb_type name="DFFNS" blif_model=".subckt dffns" num_pb="1">
                  <input name="D" num_pins="1"/>
                  <input name="S" num_pins="1"/>
                  <output name="Q" num_pins="1"/>
                  <clock name="C" num_pins="1"/>
                  <T_setup value="5.2e-11" port="DFFNS.D" clock="C"/>
                  <T_hold value="0.0" port="DFFNS.D" clock="C"/>
                  <T_setup value="2e-11" port="DFFNS.S" clock="C"/>
                  <T_hold value="7e-11" port="DFFNS.S" clock="C"/>
                  <T_clock_to_Q max="8.4e-11" port="DFFNS.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct input="DFFNS.Q" name="FF-Q" output="ff.Q"/>
                  <direct input="ff.D" name="DFFNS-D" output="DFFNS.D">
                    <pack_pattern name="LUT+DFFNS" in_port="ff.D" out_port="DFFNS.D"/>
                  </direct>
                  <direct input="ff.clk" name="DFFNS-clk" output="DFFNS.C"/>
                  <direct input="ff.S" name="DFFNS-preset" output="DFFNS.S"/>
                </interconnect>
              </mode>
              <mode name="DFFSR">
                <pb_type name="DFFSR" blif_model=".subckt dffsr" num_pb="1">
                  <input name="D" num_pins="1"/>
                  <input name="S" num_pins="1"/>
                  <input name="R" num_pins="1"/>
                  <output name="Q" num_pins="1"/>
                  <clock name="C" num_pins="1"/>
                  <T_setup value="5.2e-11" port="DFFSR.D" clock="C"/>
                  <T_hold value="0.0" port="DFFSR.D" clock="C"/>
                  <T_setup value="2e-11" port="DFFSR.S" clock="C"/>
                  <T_hold value="7e-11" port="DFFSR.S" clock="C"/>
                  <T_setup value="2e-11" port="DFFSR.R" clock="C"/>
                  <T_hold value="7e-11" port="DFFSR.R" clock="C"/>
                  <T_clock_to_Q max="8.4e-11" port="DFFSR.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct input="DFFSR.Q" name="FF-Q" output="ff.Q"/>
                  <direct input="ff.D" name="DFFSR-D" output="DFFSR.D">
                    <pack_pattern name="LUT+DFFSR" in_port="ff.D" out_port="DFFSR.D"/>
                  </direct>
                  <direct input="ff.clk" name="DFFSR-clk" output="DFFSR.C"/>
                  <direct input="ff.S" name="DFFSR-preset" output="DFFSR.S"/>
                  <direct input="ff.R" name="DFFSR-reset" output="DFFSR.R"/>
                </interconnect>
              </mode>
              <mode name="DFFNSR">
                <pb_type name="DFFNSR" blif_model=".subckt dffnsr" num_pb="1">
                  <input name="D" num_pins="1"/>
                  <input name="S" num_pins="1"/>
                  <input name="R" num_pins="1"/>
                  <output name="Q" num_pins="1"/>
                  <clock name="C" num_pins="1"/>
                  <T_setup value="5.2e-11" port="DFFNSR.D" clock="C"/>
                  <T_hold value="0.0" port="DFFNSR.D" clock="C"/>
                  <T_setup value="2e-11" port="DFFNSR.S" clock="C"/>
                  <T_hold value="7e-11" port="DFFNSR.S" clock="C"/>
                  <T_setup value="2e-11" port="DFFNSR.R" clock="C"/>
                  <T_hold value="7e-11" port="DFFNSR.R" clock="C"/>
                  <T_clock_to_Q max="8.4e-11" port="DFFNSR.Q" clock="C"/>
                </pb_type>
                <interconnect>
                  <direct input="DFFNSR.Q" name="FF-Q" output="ff.Q"/>
                  <direct input="ff.D" name="DFFNSR-D" output="DFFNSR.D">
                    <pack_pattern name="LUT+DFFNSR" in_port="ff.D" out_port="DFFNSR.D"/>
                  </direct>
                  <direct input="ff.clk" name="DFFNSR-clk" output="DFFNSR.C"/>
                  <direct input="ff.S" name="DFFNSR-preset" output="DFFNSR.S"/>
                  <direct input="ff.R" name="DFFNSR-reset" output="DFFNSR.R"/>
                </interconnect>
              </mode>
            </pb_type>
            <interconnect>
              <direct name="direct1" input="ble4.in" output="lut4[0:0].in"/>
              <direct name="direct2" input="lut4.out" output="ff.D">
                <pack_pattern name="LUT+LATCH" in_port="lut4.out" out_port="ff.D"/>
                <pack_pattern name="LUT+DFF" in_port="lut4.out" out_port="ff.D"/>
                <pack_pattern name="LUT+DFFN" in_port="lut4.out" out_port="ff.D"/>
                <pack_pattern name="LUT+DFFR" in_port="lut4.out" out_port="ff.D"/>
                <pack_pattern name="LUT+DFFNR" in_port="lut4.out" out_port="ff.D"/>
                <pack_pattern name="LUT+DFFS" in_port="lut4.out" out_port="ff.D"/>
                <pack_pattern name="LUT+DFFNS" in_port="lut4.out" out_port="ff.D"/>
                <pack_pattern name="LUT+DFFSR" in_port="lut4.out" out_port="ff.D"/>
                <pack_pattern name="LUT+DFFNSR" in_port="lut4.out" out_port="ff.D"/>
                <delay_constant max="4.8e-11" min="4.6e-11" in_port="lut4.out" out_port="ff.D"/>
              </direct>
              <direct name="direct3" input="ble4.clk" output="ff.clk"/>
              <direct name="direct4" input="ble4.reset" output="ff.R"/>
              <direct name="direct5" input="ble4.preset" output="ff.S"/>
              <mux name="mux1" input="lut4.out ff.Q" output="ble4.out">
                <delay_constant max="0.0" min="0.0" in_port="lut4.out" out_port="ble4.out"/>
                <delay_constant max="1.16e-10" min="8.3e-11" in_port="ff.Q" out_port="ble4.out"/>
              </mux>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct1" input="fle.in" output="ble4.in"/>
            <direct name="direct2" input="ble4.out" output="fle.out"/>
            <direct name="direct3" input="fle.clk" output="ble4.clk"/>
            <direct name="direct4" input="fle.reset" output="ble4.reset"/>
            <direct name="direct5" input="fle.preset" output="ble4.preset"/>
          </interconnect>
        </mode>
        <!-- Define n1_lut6 mode ends -->
        <!-- Define shift register mode begins -->
       
        <!-- Define shift_register mode end -->
      </pb_type>
      <interconnect>
        <complete name="crossbar0" input="clb.I2 clb.I3 fle[7:0].out" output="fle[7:0].in[0]">
          <delay_constant max="249e-12" in_port="clb.I2 clb.I3" out_port="fle[7:0].in[0]" />
          <delay_constant max="249e-12" in_port="fle[7:0].out"  out_port="fle[7:0].in[0]" />
        </complete>
        <complete name="crossbar1" input="clb.I1 clb.I2 fle[7:0].out" output="fle[7:0].in[1]">
          <delay_constant max="249e-12" in_port="clb.I1 clb.I2" out_port="fle[7:0].in[1]" />
          <delay_constant max="249e-12" in_port="fle[7:0].out"  out_port="fle[7:0].in[1]" />
        </complete>
        <complete name="crossbar2" input="clb.I0 clb.I1 fle[7:0].out" output="fle[7:0].in[2]">
          <delay_constant max="249e-12" in_port="clb.I0 clb.I1" out_port="fle[7:0].in[2]" />
          <delay_constant max="249e-12" in_port="fle[7:0].out"  out_port="fle[7:0].in[2]" />
        </complete>
        <complete name="crossbar3" input="clb.I1 clb.I3 fle[7:0].out" output="fle[7:0].in[3]">
          <delay_constant max="249e-12" in_port="clb.I1 clb.I3" out_port="fle[7:0].in[3]" />
          <delay_constant max="249e-12" in_port="fle[7:0].out"  out_port="fle[7:0].in[3]" />
        </complete>

        <complete name="clks" input="clb.clk" output="fle[7:0].clk">
        </complete>
        <complete name="resets" input="clb.reset" output="fle[7:0].reset">
        </complete>
        <direct name="clbouts1" input="fle[7:0].out[0:0]" output="clb.O[7:0]">
          <delay_constant max="172e-12" in_port="fle[7:0].out[0:0]" out_port="clb.O[7:0]"/>
        </direct>

        <!-- Carry chain links -->
        <complete name="carry_in" input="clb.cin clb.cin_trick fle[7:0].out[0:0]" output="fle[0:0].cin">
          <pack_pattern name="chain" in_port="clb.cin" out_port="fle[0:0].cin"/>
        </complete>
        <direct name="carry_out" input="fle[7:7].cout" output="clb.cout">
          <pack_pattern name="chain" in_port="fle[7:7].cout" out_port="clb.cout"/>
        </direct>
        <direct name="carry_link" input="fle[6:0].cout" output="fle[7:1].cin">
          <pack_pattern name="chain" in_port="fle[6:0].cout" out_port="fle[7:1].cin"/>
        </direct>

        <!-- Scan chain links: Do NOT use pack patterns here.
                               They are testing elements and are NOT dealed by packers -->
        <direct name="sc_in" input="clb.sc_in" output="fle[0:0].sc_in">
          <delay_constant max="16e-12" in_port="clb.sc_in" out_port="fle[0:0].sc_in"/>
        </direct>
        <direct name="sc_out" input="fle[7:7].sc_out" output="clb.sc_out">
          <delay_constant max="16e-12" in_port="fle[7:7].sc_out" out_port="clb.sc_out"/>
        </direct>
        <direct name="sc_link" input="fle[6:0].sc_out" output="fle[7:1].sc_in">
          <delay_constant max="16e-12" in_port="fle[6:0].sc_out" out_port="fle[7:1].sc_in"/>
        </direct>
      </interconnect>
    </pb_type>
    <!-- Define general purpose logic block (CLB) ends -->
    <!-- Define single-mode dual-port memory begin -->
    <pb_type name="memory">
      <input  name="waddr" num_pins="9"/>
      <input  name="raddr" num_pins="9"/>
      <input  name="d_in"  num_pins="32"/>
      <input  name="wenb"  num_pins="32"/>
      <input  name="wen"   num_pins="1"/>
      <input  name="ren"   num_pins="1"/>
      <output name="d_out" num_pins="32"/>
      <clock  name="rclk"  num_pins="1"/>
      <clock  name="wclk"  num_pins="1"/>
      <!-- Specify the multimode 512x32=16Kb memory block -->
      <mode name="mem_16K_dp">
         <!-- There is an issue with the port_class="data_in" blocking us from mapping anything into the bram with signal wider than 1 bit data -->	  
	<pb_type blif_model=".subckt DP_RAM16K" name="mem_16K_dp" num_pb="1">
          <input  name="waddr" num_pins="9"/>
          <input  name="raddr" num_pins="9"/>
          <input  name="d_in"  num_pins="32"/>
      	  <input  name="wenb"  num_pins="32"/>
          <input  name="wen"   num_pins="1"/>
          <input  name="ren"   num_pins="1"/>
          <output name="d_out" num_pins="32"/>
          <clock  name="rclk"  num_pins="1"/>
          <clock  name="wclk"  num_pins="1"/>
          <!-- Delay extracted from standard cell librarie -->
          <T_setup value="93e-12"     port="mem_16K_dp.waddr" clock="wclk"/>
          <T_setup value="108e-12"    port="mem_16K_dp.raddr" clock="rclk"/>
          <T_setup value="38e-12"     port="mem_16K_dp.d_in"  clock="wclk"/>
	  <T_setup value="45e-12"     port="mem_16K_dp.wenb"  clock="wclk"/>
          <T_setup value="116e-12"    port="mem_16K_dp.wen"   clock="wclk"/>
          <T_setup value="128e-12"    port="mem_16K_dp.ren"   clock="rclk"/>
          <T_clock_to_Q max="328e-12" port="mem_16K_dp.d_out" clock="rclk"/>
          <power method="pin-toggle">
            <port name="rclk" energy_per_toggle="17.9e-12"/>
            <port name="wclk" energy_per_toggle="17.9e-12"/>
            <static_power power_per_instance="0.0"/>
          </power>
        </pb_type>
        <interconnect>
          <direct name="waddress" input="memory.waddr" output="mem_16K_dp.waddr">
            <delay_constant max="132e-12" in_port="memory.waddr" out_port="mem_16K_dp.waddr"/>
          </direct>
          <direct name="raddress" input="memory.raddr" output="mem_16K_dp.raddr">
            <delay_constant max="132e-12" in_port="memory.raddr" out_port="mem_16K_dp.raddr"/>
          </direct>
          <direct name="data_input" input="memory.d_in" output="mem_16K_dp.d_in">
            <delay_constant max="132e-12" in_port="memory.d_in" out_port="mem_16K_dp.d_in"/>
          </direct>
          <direct name="write_mask" input="memory.wenb" output="mem_16K_dp.wenb">
            <delay_constant max="132e-12" in_port="memory.wenb" out_port="mem_16K_dp.wenb"/>
          </direct>
          <direct name="writeen" input="memory.wen" output="mem_16K_dp.wen">
            <delay_constant max="132e-12" in_port="memory.wen" out_port="mem_16K_dp.wen"/>
          </direct>
          <direct name="readen" input="memory.ren" output="mem_16K_dp.ren">
            <delay_constant max="132e-12" in_port="memory.ren" out_port="mem_16K_dp.ren"/>
          </direct>
          <direct name="dataout" input="mem_16K_dp.d_out" output="memory.d_out">
            <delay_constant max="40e-12" in_port="mem_16K_dp.d_out" out_port="memory.d_out"/>
          </direct>
          <direct name="rclk" input="memory.rclk" output="mem_16K_dp.rclk"/>
          <direct name="wclk" input="memory.wclk" output="mem_16K_dp.wclk"/>
        </interconnect>
      </mode>
    </pb_type>
    <!-- Define multi-mode dual-port memory end -->
    <!-- Define QL_DSP begin -->
    <pb_type name="QL_DSP">
      <input name="a" num_pins="16"/>
      <input name="b" num_pins="16"/>
      <input name="c" num_pins="16"/>
      <input name="d" num_pins="16"/>
      <clock name="clk" num_pins="1"/>
      <output name="co" num_pins="1"/>
      <output name="o" num_pins="32"/>
      <mode name="QL_DSP_slice">
        <pb_type name="QL_DSP_slice" blif_model=".subckt QL_DSP" num_pb="1">
	      <input  name="A"          num_pins="16"/>
	      <input  name="B"          num_pins="16"/>
	      <input  name="C"          num_pins="16"/>
	      <input  name="D"          num_pins="16"/>
	      <clock  name="CLK"         num_pins="1"/>
	      <output name="CO"          num_pins="1"/>
	      <output name="O"          num_pins="32"/>
              <!-- QL_DSP synthesized from 12nm cells -->
              <!-- Combinatorial delay was extracted from the mapped design -->
              <delay_constant max="1.602e-9"  in_port="QL_DSP_slice.A" 		out_port="QL_DSP_slice.O"/>
              <delay_constant max="1.602e-9"  in_port="QL_DSP_slice.B" 		out_port="QL_DSP_slice.O"/>
              <delay_constant max="1.602e-9"  in_port="QL_DSP_slice.C" 		out_port="QL_DSP_slice.O"/>
              <delay_constant max="1.602e-9"  in_port="QL_DSP_slice.D" 		out_port="QL_DSP_slice.O"/>
              <delay_constant max="1.602e-9"  in_port="QL_DSP_slice.A" 		out_port="QL_DSP_slice.CO"/>
              <delay_constant max="1.602e-9"  in_port="QL_DSP_slice.B" 		out_port="QL_DSP_slice.CO"/>
              <delay_constant max="1.602e-9"  in_port="QL_DSP_slice.C" 		out_port="QL_DSP_slice.CO"/>
              <delay_constant max="1.602e-9"  in_port="QL_DSP_slice.D" 		out_port="QL_DSP_slice.CO"/>
        </pb_type>
        <interconnect>
            <direct name="a2a" input="QL_DSP.a" output="QL_DSP_slice.A">
              <delay_constant max="249e-12" in_port="QL_DSP.a" out_port="QL_DSP_slice.A"/>
            </direct>
            <direct name="b2b" input="QL_DSP.b" output="QL_DSP_slice.B">
              <delay_constant max="249e-12" in_port="QL_DSP.b" out_port="QL_DSP_slice.B"/>
            </direct>
            <direct name="c2c" input="QL_DSP.c" output="QL_DSP_slice.C">
              <delay_constant max="249e-12" in_port="QL_DSP.c" out_port="QL_DSP_slice.C"/>
            </direct>
            <direct name="d2d" input="QL_DSP.d" output="QL_DSP_slice.D">
              <delay_constant max="249e-12" in_port="QL_DSP.d" out_port="QL_DSP_slice.D"/>
            </direct>
            <direct name="sign" input="QL_DSP_slice.CO" output="QL_DSP.co">
              <delay_constant max="249e-12" in_port="QL_DSP_slice.CO" out_port="QL_DSP.co"/>
            </direct>
            <direct name="o2o" input="QL_DSP_slice.O" output="QL_DSP.o">
              <delay_constant max="249e-12" in_port="QL_DSP_slice.O" out_port="QL_DSP.o"/>
            </direct>
            <direct name="clk2clk" input="QL_DSP.clk" output="QL_DSP_slice.CLK">
              <delay_constant max="249e-12" in_port="QL_DSP.clk" out_port="QL_DSP_slice.CLK"/>
            </direct>
        </interconnect>
      </mode>
    </pb_type>
  </complexblocklist>
<layout>
    <auto_layout aspect_ratio="1.0">
      <!--Perimeter of 'io' blocks with 'EMPTY' blocks at corners-->
      <perimeter type="io" priority="100"/>
      <corners type="EMPTY" priority="101"/>
      <!--Fill with 'clb'-->
      <fill type="clb" priority="10"/>
    </auto_layout>
    <fixed_layout name="128x128" width="130" height="130">
      <!--Perimeter of 'io' blocks with 'EMPTY' blocks at corners-->
      <perimeter type="io" priority="100"/>
      <corners type="EMPTY" priority="101"/>
      <!--Fill with 'clb'-->
      <fill type="clb" priority="10"/>
      <!--Column of 'memory' with 'EMPTY' blocks wherever a 'memory' does not fit. Vertical offset by 1 for perimeter.-->
      <!--CLB / Memory block ratio is 30. -->
      <col type="memory"  startx="2"  starty="1" repeatx="14" priority="20"/>
      <col type="EMPTY"   startx="2"  starty="1" repeatx="14" priority="19"/>
      <!--Column of 'DSP' with 'EMPTY' blocks wherever a 'DSP' does not fit. Vertical offset by 1 for perimeter.-->
      <col type="QL_DSP" startx="8"  starty="1" repeatx="14" priority="20"/>
      <col type="EMPTY"   startx="8"  starty="1" repeatx="14" priority="19"/>
    </fixed_layout>
  </layout>
</architecture>
